name: Test Operator

on:
  push:
    branches: [ main, operator ]
  pull_request:
    branches: [ main, operator ]

env:
  GO_VERSION: "1.24"

jobs:
  unit:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
          
    - name: Download dependencies
      run: go mod download
      working-directory: ./operator
      
    - name: Run config tests
      run: |
        echo "üß™ Running config tests..."
        go test ./internal/config -v
      working-directory: ./operator
      
    - name: Run injector tests
      run: |
        echo "üß™ Running injector tests..."
        go test ./internal/injector -v
      working-directory: ./operator
      
    - name: Run observability tests  
      run: |
        echo "üß™ Running observability tests..."
        go test ./internal/observability -v
      working-directory: ./operator
      
    - name: Run webhook tests
      run: |
        echo "üß™ Running webhook tests..."
        go test ./internal/webhook -v
      working-directory: ./operator
      
    - name: Run controller tests
      run: |
        echo "üß™ Running controller tests..."
        go test ./internal/controller -v
      working-directory: ./operator
        
    - name: Generate test coverage
      run: |
        echo "üìä Generating test coverage report..."
        go test -coverprofile=coverage.out ./...
        go tool cover -html=coverage.out -o coverage.html
        go tool cover -func=coverage.out
      working-directory: ./operator

  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: unit
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Install k3d
      run: |
        echo "üì¶ Installing k3d..."
        curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash
        k3d version
        
    - name: Create k3d cluster
      run: |
        echo "üöÄ Creating k3d test cluster..."
        k3d cluster create operator-test \
          --port "8080:80@loadbalancer" \
          --wait --timeout 120s
        kubectl cluster-info
        kubectl get nodes
        kubectl version --client
        
    - name: Build operator image
      run: |
        echo "üèóÔ∏è Building operator image..."
        docker build -t ghcr.io/openlit/openlit-operator:test .
        docker images | grep openlit-operator
        # Verify image was built successfully
        docker inspect ghcr.io/openlit/openlit-operator:test > /dev/null
      working-directory: ./operator
        
    - name: Build instrumentation provider image  
      run: |
        echo "üèóÔ∏è Building instrumentation provider image..."
        docker build -t ghcr.io/openlit/openlit-ai-instrumentation:test .
        docker images | grep openlit-ai-instrumentation
        # Verify image was built successfully
        docker inspect ghcr.io/openlit/openlit-ai-instrumentation:test > /dev/null
      working-directory: ./operator/providers/openlit
        
    - name: Import images to k3d cluster
      run: |
        echo "üì• Importing images to k3d cluster..."
        k3d image import ghcr.io/openlit/openlit-operator:test -c operator-test
        k3d image import ghcr.io/openlit/openlit-ai-instrumentation:test -c operator-test
        
    - name: Install OpenLIT Backend
      run: |
        echo "‚öôÔ∏è Installing OpenLIT backend..."
        helm repo add openlit https://openlit.github.io/helm/
        helm repo update
        helm install openlit openlit/openlit --wait --timeout=300s
        kubectl get svc openlit
        kubectl wait --for=condition=ready pod -l app=openlit --timeout=180s
        echo "‚úÖ OpenLIT backend is ready"
        
    - name: Deploy AutoInstrumentation CRD
      run: |
        echo "üìã Deploying AutoInstrumentation CRD..."
        kubectl apply -f operator/deploy/openlit.io_autoinstrumentations.yaml
        kubectl get crd autoinstrumentations.openlit.io
        
    - name: Deploy OpenLIT Operator
      run: |
        echo "üöÄ Deploying OpenLIT Operator..."
        # Update deployment to use our test images
        cp operator/deploy/openlit-operator.yaml operator/deploy/openlit-operator-test.yaml
        sed -i 's|ghcr.io/openlit/openlit-operator:latest|ghcr.io/openlit/openlit-operator:test|g' operator/deploy/openlit-operator-test.yaml
        sed -i 's|ghcr.io/openlit/openlit-ai-instrumentation:latest|ghcr.io/openlit/openlit-ai-instrumentation:test|g' operator/deploy/openlit-operator-test.yaml
        kubectl apply -f operator/deploy/openlit-operator-test.yaml
        
    - name: Wait for operator to be ready
      run: |
        echo "‚è≥ Waiting for operator to be ready..."
        kubectl wait --for=condition=available deployment/openlit-operator -n openlit --timeout=180s
        kubectl get pods -n openlit -l app=openlit-operator
        
    - name: Check operator health
      run: |
        echo "üîç Checking operator health..."
        OPERATOR_POD=$(kubectl get pods -n openlit -l app=openlit-operator -o jsonpath='{.items[0].metadata.name}')
        echo "Operator pod: $OPERATOR_POD"
        
        # Check if operator is running
        kubectl get pod -n openlit $OPERATOR_POD
        
        # Check operator logs for startup success
        echo "=== Operator Logs ==="
        kubectl logs -n openlit $OPERATOR_POD --tail=30
        
        # Verify webhook service exists
        kubectl get svc -n openlit openlit-webhook-service
        
    - name: Test operator functionality
      run: |
        echo "üß™ Testing operator functionality..."
        # Create test AutoInstrumentation resource
        cat <<EOF | kubectl apply -f -
        apiVersion: openlit.io/v1alpha1
        kind: AutoInstrumentation
        metadata:
          name: test-instrumentation
          namespace: default
        spec:
          selector:
            matchLabels:
              test: "e2e"
          otlp:
            endpoint: "http://openlit.default.svc.cluster.local:4318"
          python:
            instrumentation:
              provider: "openlit"
              customPackages: "opentelemetry-instrumentation-logging>=0.57b0"
        EOF
        
        # Verify resource was created
        kubectl get autoinstrumentations.openlit.io test-instrumentation -o yaml
        echo "‚úÖ AutoInstrumentation resource created successfully"
        
    - name: Deploy test application with custom packages
      run: |
        echo "üöÄ Deploying test application with custom packages..."
        kubectl apply -f operator/examples/test-application-deployment.yaml
        
        # Wait for pod to be created (may take time due to instrumentation injection)
        echo "‚è≥ Waiting for test application pod..."
        timeout 300 bash -c 'until kubectl get pod -l app=openlit-test-app 2>/dev/null; do sleep 5; done'
        
    - name: Verify instrumentation injection
      run: |
        echo "üîç Verifying instrumentation injection..."
        TEST_POD=$(kubectl get pods -l app=openlit-test-app -o jsonpath='{.items[0].metadata.name}')
        echo "Test application pod: $TEST_POD"
        
        # Check that pod has init container (sign of instrumentation)
        if kubectl describe pod $TEST_POD | grep -q "Init Containers:"; then
          echo "‚úÖ Init container detected - instrumentation injection successful"
          kubectl describe pod $TEST_POD | grep -A 5 "Init Containers:"
        else
          echo "‚ùå No init container found - instrumentation injection failed"
          exit 1
        fi
        
    - name: Verify application is running correctly
      run: |
        echo "üèÉ Verifying application is running correctly..."
        TEST_POD=$(kubectl get pods -l app=openlit-test-app -o jsonpath='{.items[0].metadata.name}')
        
        # Wait a bit for application to start and generate logs
        sleep 30
        
        # Check application logs
        echo "=== Application Logs ==="
        kubectl logs $TEST_POD --tail=20
        
        # Verify both instrumentations are working
        if kubectl logs $TEST_POD --tail=50 | grep -i "testing http requests"; then
          echo "‚úÖ Application is generating HTTP requests (OpenLIT instrumentation working)"
        else
          echo "‚ùå Application HTTP requests not found"
        fi
        
        # Check if logging instrumentation is available  
        kubectl exec $TEST_POD -- python3 -c "import sys; sys.path.insert(0, '/instrumentation-packages'); import opentelemetry.instrumentation.logging; print('‚úÖ Custom logging instrumentation is available')" || echo "Custom instrumentation test failed"
        
    - name: Collect diagnostic information
      if: failure()
      run: |
        echo "üîç Collecting diagnostic information..."
        
        echo "=== Cluster Overview ==="
        kubectl get all --all-namespaces
        
        echo "=== Operator Status ==="
        kubectl get pods -n openlit -l app=openlit-operator || true
        
        echo "=== Operator Logs ==="
        kubectl logs -n openlit -l app=openlit-operator --tail=100 || true
        
        echo "=== Test Application Status ==="
        kubectl get pods -l app=openlit-test-app || true
        kubectl describe pod -l app=openlit-test-app || true
        
        echo "=== AutoInstrumentation Resources ==="
        kubectl get autoinstrumentations.openlit.io -o yaml || true
        
        echo "=== Events ==="
        kubectl get events --sort-by=.metadata.creationTimestamp || true
        
    - name: Cleanup
      if: always()
      run: |
        echo "üßπ Cleaning up k3d cluster..."
        k3d cluster delete operator-test || true
