/**
 * Cross-Language Trace Comparison Utilities
 * 
 * This module provides utilities to compare traces generated by Python and TypeScript
 * OpenLIT SDKs to ensure consistency across implementations.
 */

import { Span, SpanStatusCode } from '@opentelemetry/api';
import { ReadableSpan } from '@opentelemetry/sdk-trace-base';

export interface NormalizedTrace {
  spanName: string;
  spanKind: string;
  attributes: Record<string, any>;
  events: Array<{ name: string; attributes?: Record<string, any> }>;
  status: { code: string; message?: string };
  duration?: number;
}

export interface TraceComparisonResult {
  match: boolean;
  differences: string[];
  pythonTrace?: NormalizedTrace;
  typescriptTrace?: NormalizedTrace;
}

/**
 * Normalize a TypeScript span to a comparable format
 */
export function normalizeTypeScriptSpan(span: ReadableSpan | Span): NormalizedTrace {
  const spanData = span as any;
  
  return {
    spanName: spanData.name || '',
    spanKind: spanData.kind?.toString() || 'INTERNAL',
    attributes: normalizeAttributes(spanData.attributes || {}),
    events: (spanData.events || []).map((event: any) => ({
      name: event.name || '',
      attributes: normalizeAttributes(event.attributes || {}),
    })),
    status: {
      code: spanData.status?.code === SpanStatusCode.OK ? 'OK' : 
            spanData.status?.code === SpanStatusCode.ERROR ? 'ERROR' : 'UNSET',
      message: spanData.status?.message,
    },
    duration: spanData.duration?.[0] ? spanData.duration[0] * 1e9 + spanData.duration[1] : undefined,
  };
}

/**
 * Normalize attributes for comparison (handles array/object differences)
 */
function normalizeAttributes(attrs: Record<string, any>): Record<string, any> {
  const normalized: Record<string, any> = {};
  
  for (const [key, value] of Object.entries(attrs)) {
    // Normalize arrays - sort for comparison
    if (Array.isArray(value)) {
      normalized[key] = [...value].sort();
    } 
    // Normalize numbers (handle float precision)
    else if (typeof value === 'number') {
      normalized[key] = Math.round(value * 1000) / 1000; // Round to 3 decimal places
    }
    // Normalize strings (trim whitespace)
    else if (typeof value === 'string') {
      normalized[key] = value.trim();
    }
    // Keep other types as-is
    else {
      normalized[key] = value;
    }
  }
  
  return normalized;
}

/**
 * Compare two normalized traces
 */
export function compareTraces(
  pythonTrace: NormalizedTrace,
  typescriptTrace: NormalizedTrace
): TraceComparisonResult {
  const differences: string[] = [];
  
  // Compare span names
  if (pythonTrace.spanName !== typescriptTrace.spanName) {
    differences.push(
      `Span name mismatch: Python="${pythonTrace.spanName}", TypeScript="${typescriptTrace.spanName}"`
    );
  }
  
  // Compare span kind
  if (pythonTrace.spanKind !== typescriptTrace.spanKind) {
    differences.push(
      `Span kind mismatch: Python="${pythonTrace.spanKind}", TypeScript="${typescriptTrace.spanKind}"`
    );
  }
  
  // Compare status
  if (pythonTrace.status.code !== typescriptTrace.status.code) {
    differences.push(
      `Status code mismatch: Python="${pythonTrace.status.code}", TypeScript="${typescriptTrace.status.code}"`
    );
  }
  
  // Compare attributes
  const attrDiff = compareAttributes(pythonTrace.attributes, typescriptTrace.attributes);
  differences.push(...attrDiff);
  
  // Compare events (optional - events may differ slightly)
  const eventDiff = compareEvents(pythonTrace.events, typescriptTrace.events);
  if (eventDiff.length > 0) {
    differences.push(`Event differences: ${eventDiff.join(', ')}`);
  }
  
  return {
    match: differences.length === 0,
    differences,
    pythonTrace,
    typescriptTrace,
  };
}

/**
 * Compare attributes between two traces
 */
function compareAttributes(
  pythonAttrs: Record<string, any>,
  typescriptAttrs: Record<string, any>
): string[] {
  const differences: string[] = [];
  const allKeys = new Set([...Object.keys(pythonAttrs), ...Object.keys(typescriptAttrs)]);
  
  // Critical attributes that must match
  const criticalAttributes = [
    'gen_ai.system',
    'gen_ai.operation.name',
    'gen_ai.request.model',
    'gen_ai.response.model',
    'gen_ai.usage.input_tokens',
    'gen_ai.usage.output_tokens',
    'gen_ai.usage.total_tokens',
    'gen_ai.usage.cost',
    'gen_ai.endpoint',
    'gen_ai.environment',
    'gen_ai.application_name',
  ];
  
  for (const key of allKeys) {
    const pythonValue = pythonAttrs[key];
    const typescriptValue = typescriptAttrs[key];
    
    const isCritical = criticalAttributes.includes(key);
    
    if (pythonValue === undefined && typescriptValue !== undefined) {
      if (isCritical) {
        differences.push(`Missing in Python: ${key} (TypeScript has: ${typescriptValue})`);
      }
    } else if (typescriptValue === undefined && pythonValue !== undefined) {
      if (isCritical) {
        differences.push(`Missing in TypeScript: ${key} (Python has: ${pythonValue})`);
      }
    } else if (pythonValue !== typescriptValue) {
      // For critical attributes, always report differences
      if (isCritical) {
        differences.push(
          `Attribute "${key}" mismatch: Python="${pythonValue}", TypeScript="${typescriptValue}"`
        );
      }
      // For non-critical, only report if significantly different
      else if (typeof pythonValue === 'number' && typeof typescriptValue === 'number') {
        const diff = Math.abs(pythonValue - typescriptValue);
        if (diff > 0.01) { // Allow small floating point differences
          differences.push(
            `Attribute "${key}" significant difference: Python=${pythonValue}, TypeScript=${typescriptValue}`
          );
        }
      }
    }
  }
  
  return differences;
}

/**
 * Compare events between two traces
 */
function compareEvents(
  pythonEvents: Array<{ name: string; attributes?: Record<string, any> }>,
  typescriptEvents: Array<{ name: string; attributes?: Record<string, any> }>
): string[] {
  const differences: string[] = [];
  
  if (pythonEvents.length !== typescriptEvents.length) {
    differences.push(
      `Event count mismatch: Python=${pythonEvents.length}, TypeScript=${typescriptEvents.length}`
    );
  }
  
  // Compare event names (order may differ)
  const pythonEventNames = pythonEvents.map(e => e.name).sort();
  const typescriptEventNames = typescriptEvents.map(e => e.name).sort();
  
  if (JSON.stringify(pythonEventNames) !== JSON.stringify(typescriptEventNames)) {
    differences.push(
      `Event names differ: Python=[${pythonEventNames.join(', ')}], TypeScript=[${typescriptEventNames.join(', ')}]`
    );
  }
  
  return differences;
}

/**
 * Extract key metrics from a trace for comparison
 */
export function extractKeyMetrics(trace: NormalizedTrace): {
  tokens: { input: number; output: number; total: number };
  cost: number;
  model: string;
  operation: string;
  system: string;
} {
  const attrs = trace.attributes;
  
  return {
    tokens: {
      input: attrs['gen_ai.usage.input_tokens'] || 0,
      output: attrs['gen_ai.usage.output_tokens'] || 0,
      total: attrs['gen_ai.usage.total_tokens'] || 0,
    },
    cost: attrs['gen_ai.usage.cost'] || 0,
    model: attrs['gen_ai.request.model'] || attrs['gen_ai.response.model'] || '',
    operation: attrs['gen_ai.operation.name'] || '',
    system: attrs['gen_ai.system'] || '',
  };
}

/**
 * Compare key metrics between Python and TypeScript traces
 */
export function compareMetrics(
  pythonTrace: NormalizedTrace,
  typescriptTrace: NormalizedTrace
): { match: boolean; differences: string[] } {
  const pythonMetrics = extractKeyMetrics(pythonTrace);
  const typescriptMetrics = extractKeyMetrics(typescriptTrace);
  const differences: string[] = [];
  
  // Compare tokens (allow small differences due to estimation)
  const tokenTolerance = 5; // Allow 5 token difference
  if (Math.abs(pythonMetrics.tokens.input - typescriptMetrics.tokens.input) > tokenTolerance) {
    differences.push(
      `Input tokens differ significantly: Python=${pythonMetrics.tokens.input}, TypeScript=${typescriptMetrics.tokens.input}`
    );
  }
  if (Math.abs(pythonMetrics.tokens.output - typescriptMetrics.tokens.output) > tokenTolerance) {
    differences.push(
      `Output tokens differ significantly: Python=${pythonMetrics.tokens.output}, TypeScript=${typescriptMetrics.tokens.output}`
    );
  }
  
  // Compare cost (allow small differences due to rounding)
  const costTolerance = 0.0001;
  if (Math.abs(pythonMetrics.cost - typescriptMetrics.cost) > costTolerance) {
    differences.push(
      `Cost differs: Python=${pythonMetrics.cost}, TypeScript=${typescriptMetrics.cost}`
    );
  }
  
  // Compare model (must match exactly)
  if (pythonMetrics.model !== typescriptMetrics.model) {
    differences.push(
      `Model mismatch: Python="${pythonMetrics.model}", TypeScript="${typescriptMetrics.model}"`
    );
  }
  
  // Compare operation (must match exactly)
  if (pythonMetrics.operation !== typescriptMetrics.operation) {
    differences.push(
      `Operation mismatch: Python="${pythonMetrics.operation}", TypeScript="${typescriptMetrics.operation}"`
    );
  }
  
  // Compare system (must match exactly)
  if (pythonMetrics.system !== typescriptMetrics.system) {
    differences.push(
      `System mismatch: Python="${pythonMetrics.system}", TypeScript="${typescriptMetrics.system}"`
    );
  }
  
  return {
    match: differences.length === 0,
    differences,
  };
}

/**
 * Create a test helper that validates trace consistency
 */
export function createTraceValidator(
  providerName: string,
  expectedAttributes: string[] = []
) {
  return {
    validateTrace: (trace: NormalizedTrace) => {
      const errors: string[] = [];
      
      // Check required attributes
      for (const attr of expectedAttributes) {
        if (!(attr in trace.attributes)) {
          errors.push(`Missing required attribute: ${attr}`);
        }
      }
      
      // Check system matches provider
      if (trace.attributes['gen_ai.system'] !== providerName) {
        errors.push(
          `System mismatch: expected "${providerName}", got "${trace.attributes['gen_ai.system']}"`
        );
      }
      
      // Check operation is set
      if (!trace.attributes['gen_ai.operation.name']) {
        errors.push('Missing operation name');
      }
      
      // Check tokens are present
      if (!trace.attributes['gen_ai.usage.input_tokens'] && !trace.attributes['gen_ai.usage.output_tokens']) {
        errors.push('Missing token usage information');
      }
      
      return {
        valid: errors.length === 0,
        errors,
      };
    },
  };
}
